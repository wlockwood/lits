from Controllers.FaceRecognizer import encode_faces, match_best
from Model.Image import Image
from Model.Person import Person
import unittest
from os import path
import numpy

class TestFaceRecognizer(unittest.TestCase):
    my_dir = path.dirname(__file__)
    test_data_path = "test-data\\"

    known_images = [Image(test_data_path + "known\\will.jpg", skip_md_init=True)]
    test_faces = encode_faces(known_images)
    test_person = Person("will")
    test_person.encodings = test_faces[0].encodings_in_image

    will_as_unknown = Image(test_data_path + "unknown\\will2.jpg", skip_md_init=True)
    sam_will_trail = Image(test_data_path + "unknown\\sam will trail 2.jpg", skip_md_init=True)
    mushroom = Image(test_data_path + "unknown\\mushroom.jpg", skip_md_init=True)
    multiple_people = Image(test_data_path + "unknown\\work group will.jpg", skip_md_init=True)
    different_person = Image(test_data_path + "unknown\\jackie phone.jpg", skip_md_init=True)

    # Should match when same person
    def test_one_to_one_match(self):
        unknown_images = encode_faces([self.will_as_unknown])
        best_matches = match_best([self.test_person], unknown_images[0].encodings_in_image)
        self.assertEqual(len(best_matches), 1, "face didn't match itself in another picture")

    def test_multiple_pictures_per_known(self):
        # Requires more convoluted test setup for the known person
        known_images = [Image(self.test_data_path + "known\\will\\will.jpg"),
                        Image(self.test_data_path + "known\\will\\will sunglass hat.png")]
        encode_faces(known_images)
        test_person = Person("will")
        test_person.encodings = [enc for im in known_images for enc in im.encodings_in_image]  # Flat?

        unknown_images = encode_faces([self.will_as_unknown])
        best_matches = match_best([test_person], unknown_images[0].encodings_in_image)
        self.assertEqual(1, len(best_matches), "couldn't match a face using multiple images for known person")

        unknown_images = encode_faces([self.sam_will_trail])
        best_matches = match_best([test_person], unknown_images[0].encodings_in_image)
        self.assertEqual(1, len(best_matches), "couldn't match a face using multiple images for known person")

    # Should work with multiple matches in picture
    def test_multiple_unknown_in_picture(self):
        unknown_images = encode_faces([self.multiple_people])
        best_matches = match_best([self.test_person], unknown_images[0].encodings_in_image)
        self.assertEqual(1, len(best_matches), "face didn't match with itself in a picture with other people as well")

    # Shouldn't match on different person
    def test_no_match(self):
        unknown_images = encode_faces([self.different_person])
        best_matches = match_best([self.test_person], unknown_images[0].encodings_in_image)
        self.assertEqual(0, len(best_matches), "face matched against a different face")

    # Shouldn't match on a mushroom
    def test_not_a_person(self):
        unknown_images = encode_faces([self.mushroom])
        faces_found = len(unknown_images[0].encodings_in_image)
        self.assertEqual(0, faces_found, "found a face match when looking at a mushroom")

class TestImage(unittest.TestCase):
    test_data_prefix = ""
    if __name__ == "__main__":
        test_data_prefix = "..\\"

    test_image = Image(test_data_prefix + r"test-data\unknown\sam tongue out.jpg")
    test_encoding = numpy.frombuffer(b'\x00\x00\x00\xc0\x11\xc1\xb3\xbf\x00\x00\x00@Z\xdf\x9a?\x00\x00\x00\xe0\xc6\xd4\xae?\x00\x00\x00\xa0\xfe\x14\xbf\xbf\x00\x00\x00\x00\xd5^\xc4\xbf\x00\x00\x00\xc0\nx~\xbf\x00\x00\x00\xc0\x1f\xd4\x96\xbf\x00\x00\x00 o\x12\xc1\xbf\x00\x00\x00\x80t!\xb4?\x00\x00\x00\xa0L\x8d\xcd\xbf\x00\x00\x00`\xe6"\xc7?\x00\x00\x00\x006\xc3\x83?\x00\x00\x00\x80\x82\xb9\xd0\xbf\x00\x00\x00\xe0\xb2P\xa4?\x00\x00\x00\xc0\x08t\xb2?\x00\x00\x00\xe0\x13L\xcd?\x00\x00\x00`Xm\xc4\xbf\x00\x00\x00\xc0$+\xc8\xbf\x00\x00\x00\xe0T$\xc6\xbf\x00\x00\x00`pP\xb2\xbf\x00\x00\x00\xc0a\x1d\xa8\xbf\x00\x00\x00\xc0: \xb8?\x00\x00\x00@\xc7e\xa5\xbf\x00\x00\x00\x00\x1d\xab\xb2?\x00\x00\x00\xc0yo\xae\xbf\x00\x00\x00\xe0\x0e\x9f\xce\xbf\x00\x00\x00\xc0j\xb4\xad\xbf\x00\x00\x00\x00\x8a\xd1\xa2\xbf\x00\x00\x00@gA\x9b?\x00\x00\x00\x00p\x89D\xbf\x00\x00\x00\xa0YI\x9f\xbf\x00\x00\x00 \xe7"\xb2?\x00\x00\x00`\xb8|\xb0\xbf\x00\x00\x00`&\x01\xb9?\x00\x00\x00\x00\xd9E\xb9?\x00\x00\x00\x00\x9e2\xac?\x00\x00\x00\xe0\xbd\x8e\xba\xbf\x00\x00\x00\xe0\xe4\x8f\xc1\xbf\x00\x00\x00 }=\xd0?\x00\x00\x00\x00\x90k\xa4?\x00\x00\x00\xa0\x07\x05\xd0\xbf\x00\x00\x00\x00\xce3\xac\xbf\x00\x00\x00\x00\x84\xa9\xb1?\x00\x00\x00@t\x8f\xc9?\x00\x00\x00 \xdb\xea\xc9?\x00\x00\x00\xc0Ch\x94\xbf\x00\x00\x00\xc0*\xdd\x89?\x00\x00\x00\xc0\\\x99\xb7\xbf\x00\x00\x00\xc0xD\xc4?\x00\x00\x00\xe0!\xd4\xd3\xbf\x00\x00\x00 `\xd1\x9e?\x00\x00\x00\x80w\x9c\xc3?\x00\x00\x00\xc0\xb1\xb0\xa3?\x00\x00\x00\x80\xc1-\xb8?\x00\x00\x00@\xe3\x16\xb0?\x00\x00\x00\xc0\xee\xf2\xcc\xbf\x00\x00\x00\xe0\xbc\xc7\xb6?\x00\x00\x00@\xca\xf7\xba?\x00\x00\x00 \xfcn\xc5\xbf\x00\x00\x00\x80p:e?\x00\x00\x00\x80Ma\xb7?\x00\x00\x00\x00>\xec\xc7\xbf\x00\x00\x00`\x0f+\x9c\xbf\x00\x00\x00\xc0\xba\x1d\xb1\xbf\x00\x00\x00`4\x17\xcf?\x00\x00\x00\xe0\x1fZ\xb6?\x00\x00\x00\x00BA\xc2\xbf\x00\x00\x00\x80.\xf4\xc5\xbf\x00\x00\x00\xc0+=\xc4?\x00\x00\x00\x80\xe8\xee\xc4\xbf\x00\x00\x00`]\xd6\xc2\xbf\x00\x00\x00@\x13\x0b\x8c?\x00\x00\x00`>\xa8\xc5\xbf\x00\x00\x00`\xb1\xe0\xc2\xbf\x00\x00\x00\xe0tM\xd0\xbf\x00\x00\x00\xe0UO\x9e\xbf\x00\x00\x00 \x02\x14\xd6?\x00\x00\x00`\xb6\x14\xca?\x00\x00\x00\xc0\xfa\xed\xc4\xbf\x00\x00\x00\xe0&\xee\xad?\x00\x00\x00\xe0+#\x9b\xbf\x00\x00\x00\x00\x04\x9e\x94\xbf\x00\x00\x00\x00"\xd9\xbf?\x00\x00\x00 \xd3d\xbe?\x00\x00\x00`\xb0x\xa8\xbf\x00\x00\x00\xe0\x117\xbb\xbf\x00\x00\x00\xe0W~\xb7\xbf\x00\x00\x00\x80\xf6M\x9c\xbf\x00\x00\x00`2j\xce?\x00\x00\x00\xc0aR\xb2\xbf\x00\x00\x00\x00\x18\xa6|?\x00\x00\x00\x00\x04\xb9\xd0?\x00\x00\x00\x80_|\xa4?\x00\x00\x00\xa0c\x0c\x93?\x00\x00\x00\xe0\xcah\x98?\x00\x00\x00\x00\xbd\xebs?\x00\x00\x00\x00\xd3\xe1\xb3\xbf\x00\x00\x00\xa0\xfd\x84\xab\xbf\x00\x00\x00\x80\x0b\xd1\xbf\xbf\x00\x00\x00\xc0\x8f\r\xa0\xbf\x00\x00\x00\xe0\xd9\xac\x84\xbf\x00\x00\x00\xa0\xa8\x95\xab\xbf\x00\x00\x00\xc0A;\xa4?\x00\x00\x00@\xbd\x0f\xc1?\x00\x00\x00\xc0$a\xc6\xbf\x00\x00\x00\xe0\xf3\xc7\xc9?\x00\x00\x00\xc0\xfa9\xa5\xbf\x00\x00\x00\x80\x88\xb1\x9d?\x00\x00\x00\x00\xc3<\x82\xbf\x00\x00\x00\x00\xc2Kk\xbf\x00\x00\x00\xc0g\x01\xc2\xbf\x00\x00\x00\xc0\xc1\xf3\xac\xbf\x00\x00\x00\x80\xf7\xb8\xbe?\x00\x00\x00@\x90\xe5\xc4\xbf\x00\x00\x00@\xf6\xdf\xc3?\x00\x00\x00`\xce\x19\xc8?\x00\x00\x00\x80\\\xd5\xb7?\x00\x00\x00\xa0\x90\xeb\xbb?\x00\x00\x00\x80\xcb\xa8\xc2?\x00\x00\x00\x80\xd8_\xb3?\x00\x00\x00\xc0E\xed\x98\xbf\x00\x00\x00\xc0\x86A\x9c\xbf\x00\x00\x00\x00\x17\x9a\xcc\xbf\x00\x00\x00\x80\xba\x91\xb1\xbf\x00\x00\x00\x80j6\xbe?\x00\x00\x00\xe0>\x89w?\x00\x00\x00\xc0\x0f*\xa4?\x00\x00\x00\xa0xH\xb4?', dtype="float64")

    # Tests unused code now
    def test_rw_cycle(self):
        self.test_image.init_metadata()
        self.test_image.set_encoding_in_metadata(self.test_encoding)

        readout = self.test_image.get_encodings_from_metadata()
        all_match = True
        for i in range(len(self.test_encoding)):
            if self.test_encoding[i] != readout[i]:
                all_match = False
                break
        self.assertEqual(True, all_match, "test array doesn't match itself after having been written to and from file")